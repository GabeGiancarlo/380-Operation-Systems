<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Final Exam Study Hub - CPSC 380</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            border: 1px solid #333;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
            background: #0a0a0a;
        }
        
        .header h1 {
            font-size: 2em;
            color: #ffffff;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: -0.5px;
        }
        
        .header p {
            font-size: 1em;
            color: #888;
            font-weight: 300;
        }
        
        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            border: 1px solid #222;
            padding: 20px;
            background: #0a0a0a;
            transition: border-color 0.3s;
        }
        
        .card:hover {
            border-color: #444;
        }
        
        .card h2 {
            color: #ffffff;
            font-size: 1.3em;
            margin-bottom: 15px;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
            font-weight: 400;
            letter-spacing: -0.3px;
        }
        
        .card p {
            color: #aaa;
            margin-bottom: 15px;
            font-size: 0.9em;
            font-weight: 300;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: transparent;
            color: #ffffff;
            text-decoration: none;
            border: 1px solid #333;
            font-size: 0.9em;
            transition: border-color 0.3s, background 0.3s;
            font-family: 'Inter', sans-serif;
            font-weight: 400;
        }
        
        .btn:hover {
            border-color: #666;
            background: #111;
        }
        
        .iframe-container {
            border: 1px solid #222;
            margin-top: 30px;
            display: none;
            background: #000;
            padding: 10px;
        }
        
        .iframe-container.active {
            display: block;
        }
        
        .iframe-container iframe {
            width: 100%;
            height: 800px;
            border: 1px solid #222;
            background: #000;
        }
        
        .close-btn {
            float: right;
            background: transparent;
            color: #fff;
            border: 1px solid #333;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 10px;
            font-family: 'Inter', sans-serif;
            transition: border-color 0.3s, background 0.3s;
        }
        
        .close-btn:hover {
            border-color: #666;
            background: #111;
        }
        
        .csv-viewer {
            border: 1px solid #222;
            margin-top: 30px;
            display: none;
            background: #0a0a0a;
            padding: 20px;
        }
        
        .csv-viewer.active {
            display: block;
        }
        
        .csv-viewer h3 {
            color: #fff;
            margin-bottom: 15px;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
            font-weight: 400;
            letter-spacing: -0.3px;
        }
        
        .flashcard-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 10px;
            border: 1px solid #222;
            background: #000;
            color: #fff;
            font-size: 0.9em;
            font-family: 'Inter', sans-serif;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #444;
        }
        
        .search-box::placeholder {
            color: #555;
        }
        
        .category-filter {
            padding: 10px;
            border: 1px solid #222;
            background: #000;
            color: #fff;
            font-size: 0.9em;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
        }
        
        .category-filter:focus {
            outline: none;
            border-color: #444;
        }
        
        .flashcard-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px auto;
            max-width: 100%;
            padding: 0 20px;
            min-height: 450px;
        }
        
        #cardView {
            display: flex !important;
        }
        
        .flashcard {
            width: 100%;
            max-width: 600px;
            height: 400px;
            perspective: 1000px;
            cursor: pointer;
            margin: 0 auto;
        }
        
        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }
        
        .flashcard-front,
        .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border: 1px solid #333;
            background: #111;
            padding: 25px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .flashcard-back {
            transform: rotateY(180deg);
            background: #0a0a0a;
        }
        
        .flashcard-category {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .flashcard-term {
            font-size: 1.4em;
            font-weight: 600;
            color: #fff;
            margin-bottom: 15px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            flex-shrink: 0;
        }
        
        .flashcard-hint {
            font-size: 0.85em;
            color: #666;
            margin-top: auto;
            text-align: center;
            font-style: italic;
            flex-shrink: 0;
            padding-top: 10px;
        }
        
        .flashcard-definition {
            font-size: 1em;
            color: #ddd;
            line-height: 1.5;
            margin-bottom: 15px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        
        .flashcard-example {
            font-size: 0.9em;
            color: #aaa;
            border-top: 1px solid #222;
            padding-top: 12px;
            margin-top: 10px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex-shrink: 0;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .flashcard-example strong {
            color: #fff;
        }
        
        .flashcard-nav {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }
        
        .nav-btn {
            padding: 10px 20px;
            border: 1px solid #333;
            background: #000;
            color: #fff;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.9em;
            transition: border-color 0.3s, background 0.3s;
        }
        
        .nav-btn:hover:not(:disabled) {
            border-color: #666;
            background: #111;
        }
        
        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .flashcard-counter {
            color: #888;
            font-size: 0.9em;
        }
        
        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .stat {
            border: 1px solid #222;
            padding: 10px;
            background: #000;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #888;
            font-weight: 300;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: 500;
            color: #fff;
        }
        
        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .toggle-btn {
            padding: 8px 15px;
            border: 1px solid #333;
            background: #000;
            color: #fff;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 0.85em;
            transition: border-color 0.3s, background 0.3s;
        }
        
        .toggle-btn.active {
            border-color: #666;
            background: #111;
        }
        
        .error {
            color: #ff4444;
            padding: 10px;
            border: 1px solid #ff4444;
            background: #1a0000;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Operating Systems Final Exam Study Hub</h1>
            <p>CPSC 380</p>
        </div>
        
        <div class="cards">
            <div class="card">
                <h2>Comprehensive Study Guide</h2>
                <p>Detailed study guide covering all topics from lectures and assignments.</p>
                <div class="btn-group">
                    <a href="#" class="btn" onclick="showStudyGuide(); return false;">View</a>
                    <a href="Comprehensive_Final_Study_Guide.html" class="btn" target="_blank">Open in New Tab</a>
                </div>
            </div>
            
            <div class="card">
                <h2>Four-Page Cheat Sheet</h2>
                <p>Dense, comprehensive reference sheet with examples and problems (front and back of 2 sheets).</p>
                <div class="btn-group">
                    <a href="#" class="btn" onclick="showCheatSheet(); return false;">View</a>
                    <a href="Final_Exam_Cheat_Sheet.html" class="btn" target="_blank">Open in New Tab</a>
                    <a href="Final_Exam_Cheat_Sheet.html" class="btn" download>Download</a>
                </div>
            </div>
            
            <div class="card">
                <h2>Flashcard Dictionary</h2>
                <p>100+ terms and definitions organized by category.</p>
                <div class="btn-group">
                    <a href="#" class="btn" onclick="showFlashcards(); return false;">View</a>
                    <a href="Flashcard_Dictionary.csv" class="btn" download>Download CSV</a>
                </div>
            </div>
        </div>
        
        <div id="studyGuideViewer" class="iframe-container">
            <button class="close-btn" onclick="hideViewer('studyGuideViewer')">✕ Close</button>
            <iframe src="Comprehensive_Final_Study_Guide.html"></iframe>
        </div>
        
        <div id="cheatSheetViewer" class="iframe-container">
            <button class="close-btn" onclick="hideViewer('cheatSheetViewer')">✕ Close</button>
            <iframe src="Final_Exam_Cheat_Sheet.html"></iframe>
        </div>
        
        <div id="flashcardViewer" class="csv-viewer">
            <button class="close-btn" onclick="hideViewer('flashcardViewer')">✕ Close</button>
            <h3>Interactive Flashcards</h3>
            <div id="errorMessage" style="display: none;" class="error"></div>
            
            <div class="view-toggle">
                <button class="toggle-btn active" id="cardViewBtn" onclick="switchView('card')">Card View</button>
                <button class="toggle-btn" id="listViewBtn" onclick="switchView('list')">List View</button>
            </div>
            
            <div class="flashcard-controls">
                <input type="text" id="searchBox" class="search-box" placeholder="Search terms, definitions, or categories..." onkeyup="handleSearch()">
                <select id="categoryFilter" class="category-filter" onchange="handleCategoryFilter()">
                    <option value="">All Categories</option>
                </select>
            </div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">Total Terms</div>
                    <div class="stat-value" id="totalTerms">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Showing</div>
                    <div class="stat-value" id="showingTerms">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Current</div>
                    <div class="stat-value" id="currentCard">0</div>
                </div>
            </div>
            
            <!-- Card View -->
            <div id="cardView" class="flashcard-container">
                <div class="flashcard" id="flashcard" onclick="flipCard()">
                    <div class="flashcard-inner">
                        <div class="flashcard-front">
                            <div class="flashcard-category" id="cardCategory"></div>
                            <div class="flashcard-term" id="cardTerm"></div>
                            <div class="flashcard-hint">Click to flip</div>
                        </div>
                        <div class="flashcard-back">
                            <div class="flashcard-category" id="cardCategoryBack"></div>
                            <div class="flashcard-definition" id="cardDefinition"></div>
                            <div class="flashcard-example" id="cardExample"></div>
                        </div>
                    </div>
                </div>
                <div class="flashcard-nav">
                    <button class="nav-btn" id="prevBtn" onclick="previousCard()">← Previous</button>
                    <span class="flashcard-counter" id="cardCounter"></span>
                    <button class="nav-btn" id="nextBtn" onclick="nextCard()">Next →</button>
                </div>
            </div>
            
            <!-- List View -->
            <div id="listView" style="display: none;">
                <table class="csv-table" id="flashcardTable">
                    <thead>
                        <tr>
                            <th>Term</th>
                            <th>Definition</th>
                            <th>Category</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody id="flashcardBody"></tbody>
                </table>
            </div>
        </div>
    </div>
    
    <script>
        // Flashcard data embedded directly (converted from CSV + study guide additions)
        let flashcardData = [
            {term: "Operating System", definition: "System software that manages computer hardware and software resources and provides common services for computer programs", category: "Introduction", example: "Windows, Linux, macOS"},
            {term: "System Call", definition: "Interface the OS offers to applications to request services", category: "Introduction", example: "fork(), exec(), open(), read()"},
            {term: "Bootstrap Program", definition: "Initial program loaded when computer starts; loads OS kernel", category: "Introduction", example: "BIOS loads bootloader which loads OS"},
            {term: "Interrupt", definition: "Signal from hardware/software that causes CPU to save state and execute handler", category: "Introduction", example: "Device signals I/O completion"},
            {term: "DMA (Direct Memory Access)", definition: "Hardware mechanism allowing devices to transfer data directly to/from memory without CPU", category: "Introduction", example: "Disk controller transfers data to memory, interrupts CPU when done"},
            {term: "Process", definition: "Program in execution with its own address space and resources", category: "Processes", example: "Running web browser, text editor"},
            {term: "Process Control Block (PCB)", definition: "Data structure containing all information needed to manage a process", category: "Processes", example: "State, PC, registers, memory info"},
            {term: "Context Switch", definition: "Operation of switching CPU from one process to another", category: "Processes", example: "Save current process state, load new process state"},
            {term: "Fork", definition: "System call that creates new child process as duplicate of parent", category: "Processes", example: "Parent creates child with fork(), child gets PID 0"},
            {term: "Exec", definition: "System call that loads new program into current process, replacing current program", category: "Processes", example: "execvp() loads /bin/ls into process"},
            {term: "Wait", definition: "System call that causes parent to wait for child process to terminate", category: "Processes", example: "Parent calls wait() to get child exit status"},
            {term: "Thread", definition: "Lightweight process; flow of control within a process", category: "Threads", example: "Multiple threads in web browser: UI, network, rendering"},
            {term: "User-Level Threads", definition: "Threads managed by user-level thread library", category: "Threads", example: "POSIX Pthreads in user mode"},
            {term: "Kernel-Level Threads", definition: "Threads supported directly by kernel", category: "Threads", example: "Windows threads, Linux threads"},
            {term: "Many-to-One Model", definition: "Many user threads mapped to single kernel thread", category: "Threads", example: "One blocking thread blocks all"},
            {term: "One-to-One Model", definition: "Each user thread maps to kernel thread", category: "Threads", example: "Better concurrency, more overhead"},
            {term: "Many-to-Many Model", definition: "Many user threads mapped to many kernel threads", category: "Threads", example: "Flexible, good balance"},
            {term: "Amdahl's Law", definition: "Formula predicting speedup from parallelization", category: "Threads", example: "Speedup = 1 / ((1-P) + P/N)"},
            {term: "Race Condition", definition: "When multiple processes access shared data and outcome depends on execution order", category: "Synchronization", example: "Two processes increment counter simultaneously"},
            {term: "Critical Section", definition: "Code segment that accesses shared variables and must not execute concurrently", category: "Synchronization", example: "Code that modifies shared buffer"},
            {term: "Mutual Exclusion", definition: "Ensuring only one process can be in critical section at a time", category: "Synchronization", example: "Mutex lock prevents concurrent access"},
            {term: "Semaphore", definition: "Integer variable accessed only through atomic wait() and signal() operations", category: "Synchronization", example: "Counting semaphore tracks available resources"},
            {term: "Binary Semaphore", definition: "Semaphore with value 0 or 1; same as mutex", category: "Synchronization", example: "Protects single resource"},
            {term: "Counting Semaphore", definition: "Semaphore with unrestricted integer value", category: "Synchronization", example: "Tracks multiple available resources"},
            {term: "Mutex Lock", definition: "Simplest synchronization tool; protects critical section", category: "Synchronization", example: "pthread_mutex_lock() and unlock()"},
            {term: "Spinlock", definition: "Mutex lock that uses busy waiting", category: "Synchronization", example: "CPU spins while waiting for lock"},
            {term: "Producer-Consumer Problem", definition: "Classic synchronization problem with bounded buffer", category: "Synchronization", example: "Producers insert, consumers remove from shared buffer"},
            {term: "Readers-Writers Problem", definition: "Multiple readers can read simultaneously, only one writer at a time", category: "Synchronization", example: "Database: many readers, exclusive writers"},
            {term: "Dining Philosophers Problem", definition: "Five philosophers need two forks to eat; deadlock prevention", category: "Synchronization", example: "Classic deadlock scenario"},
            {term: "Monitor", definition: "High-level synchronization construct ensuring only one process active at a time", category: "Synchronization", example: "Java synchronized methods"},
            {term: "Condition Variable", definition: "Used with monitors for waiting and signaling", category: "Synchronization", example: "pthread_cond_wait(), pthread_cond_signal()"},
            {term: "Priority Inversion", definition: "Low-priority task holds lock needed by high-priority task", category: "Synchronization", example: "Mars Pathfinder bug"},
            {term: "CPU Utilization", definition: "Percentage of time CPU is busy", category: "Scheduling", example: "Keep CPU as busy as possible"},
            {term: "Throughput", definition: "Number of processes completed per time unit", category: "Scheduling", example: "Jobs per hour"},
            {term: "Turnaround Time", definition: "Time from process submission to completion", category: "Scheduling", example: "Total time in system"},
            {term: "Waiting Time", definition: "Time process spends waiting in ready queue", category: "Scheduling", example: "Time waiting for CPU"},
            {term: "Response Time", definition: "Time from submission until first response", category: "Scheduling", example: "Important for interactive systems"},
            {term: "FCFS (First-Come First-Served)", definition: "Non-preemptive scheduling; processes in arrival order", category: "Scheduling", example: "Simple FIFO queue"},
            {term: "SJF (Shortest Job First)", definition: "Non-preemptive; schedule shortest next CPU burst first", category: "Scheduling", example: "Optimal for minimum average waiting time"},
            {term: "Round Robin", definition: "Preemptive scheduling with time quantum", category: "Scheduling", example: "Each process gets q time units"},
            {term: "Priority Scheduling", definition: "Schedule highest priority process first", category: "Scheduling", example: "Lower number = higher priority typically"},
            {term: "Rate-Monotonic Scheduling", definition: "Real-time scheduling for periodic tasks; shorter period = higher priority", category: "Scheduling", example: "U ≤ n(2^(1/n) - 1)"},
            {term: "EDF (Earliest Deadline First)", definition: "Dynamic priority; earlier deadline = higher priority", category: "Scheduling", example: "Can achieve 100% CPU utilization"},
            {term: "Deadlock", definition: "Set of processes waiting for events that only other processes in set can cause", category: "Deadlocks", example: "Circular wait condition"},
            {term: "Mutual Exclusion (Deadlock)", definition: "At least one resource must be non-sharable", category: "Deadlocks", example: "Printer, tape drive"},
            {term: "Hold and Wait", definition: "Process holding resource waits for additional resource", category: "Deadlocks", example: "Process has printer, wants scanner"},
            {term: "No Preemption", definition: "Resources cannot be preempted", category: "Deadlocks", example: "Cannot take resource away from process"},
            {term: "Circular Wait", definition: "Circular chain of processes waiting for resources", category: "Deadlocks", example: "P1 waits for P2, P2 waits for P1"},
            {term: "Resource-Allocation Graph", definition: "Graph showing processes, resources, and request/assignment edges", category: "Deadlocks", example: "Visual representation of deadlock"},
            {term: "Deadlock Prevention", definition: "Prevent one of four necessary conditions", category: "Deadlocks", example: "Impose resource ordering"},
            {term: "Deadlock Avoidance", definition: "Require system to always be in safe state", category: "Deadlocks", example: "Banker's algorithm"},
            {term: "Deadlock Detection", definition: "Allow deadlock, detect it, then recover", category: "Deadlocks", example: "Periodic detection algorithm"},
            {term: "Banker's Algorithm", definition: "Deadlock avoidance algorithm for multiple resource instances", category: "Deadlocks", example: "Check if allocation leaves safe state"},
            {term: "Logical Address", definition: "Address generated by CPU; virtual address", category: "Memory Management", example: "Address in program"},
            {term: "Physical Address", definition: "Address seen by memory unit", category: "Memory Management", example: "Actual memory location"},
            {term: "MMU (Memory Management Unit)", definition: "Hardware that maps logical to physical addresses", category: "Memory Management", example: "Performs address translation"},
            {term: "Base Register", definition: "Starting physical address for process", category: "Memory Management", example: "Used with limit register for protection"},
            {term: "Limit Register", definition: "Size of logical address space", category: "Memory Management", example: "Used with base register for protection"},
            {term: "Dynamic Loading", definition: "Routine not loaded until called", category: "Memory Management", example: "Better memory utilization"},
            {term: "Dynamic Linking", definition: "Linking postponed until execution time", category: "Memory Management", example: "Shared libraries"},
            {term: "Swapping", definition: "Process swapped out of memory to backing store", category: "Memory Management", example: "Free up memory for other processes"},
            {term: "First Fit", definition: "Allocate first hole large enough", category: "Memory Management", example: "Fast allocation"},
            {term: "Best Fit", definition: "Allocate smallest hole large enough", category: "Memory Management", example: "Minimizes waste"},
            {term: "Worst Fit", definition: "Allocate largest hole", category: "Memory Management", example: "Leaves large remaining holes"},
            {term: "Internal Fragmentation", definition: "Memory allocated but not used within allocated block", category: "Memory Management", example: "Waste within page"},
            {term: "External Fragmentation", definition: "Enough total memory but not contiguous", category: "Memory Management", example: "Holes between allocated blocks"},
            {term: "Compaction", definition: "Shuffle memory to place all free memory together", category: "Memory Management", example: "Requires dynamic relocation"},
            {term: "Page", definition: "Fixed-size block of logical memory", category: "Virtual Memory", example: "Typically 4KB"},
            {term: "Frame", definition: "Fixed-size block of physical memory", category: "Virtual Memory", example: "Same size as page"},
            {term: "Page Table", definition: "Data structure mapping page numbers to frame numbers", category: "Virtual Memory", example: "One per process"},
            {term: "TLB (Translation Lookaside Buffer)", definition: "Fast cache for page table entries", category: "Virtual Memory", example: "Reduces memory accesses"},
            {term: "Page Fault", definition: "Reference to page not in memory", category: "Virtual Memory", example: "Trap to OS, load page"},
            {term: "Demand Paging", definition: "Bring page into memory only when needed", category: "Virtual Memory", example: "Lazy loading"},
            {term: "FIFO Page Replacement", definition: "Replace oldest page", category: "Virtual Memory", example: "Simple but may replace frequently used"},
            {term: "Optimal Page Replacement", definition: "Replace page that will not be used for longest time", category: "Virtual Memory", example: "Theoretical optimal"},
            {term: "LRU (Least Recently Used)", definition: "Replace page not used for longest time", category: "Virtual Memory", example: "Good approximation of optimal"},
            {term: "Working Set", definition: "Set of pages used in most recent Δ references", category: "Virtual Memory", example: "Approximation of locality"},
            {term: "Thrashing", definition: "Process spends more time paging than executing", category: "Virtual Memory", example: "Insufficient frames"},
            {term: "File", definition: "Named collection of related information", category: "File Systems", example: "Document, program, data"},
            {term: "Directory", definition: "File containing list of files and subdirectories", category: "File Systems", example: "Organizes files hierarchically"},
            {term: "Inode", definition: "Data structure containing file metadata", category: "File Systems", example: "UNIX file system"},
            {term: "Contiguous Allocation", definition: "File occupies contiguous blocks", category: "File Systems", example: "Simple but external fragmentation"},
            {term: "Linked Allocation", definition: "File is linked list of blocks", category: "File Systems", example: "No external fragmentation, sequential access"},
            {term: "Indexed Allocation", definition: "File has index block with pointers to data blocks", category: "File Systems", example: "Supports direct access"},
            {term: "Bit Vector", definition: "Each block represented by bit for free-space management", category: "File Systems", example: "1 = free, 0 = allocated"},
            {term: "VFS (Virtual File System)", definition: "Object-oriented interface to multiple file system types", category: "File Systems", example: "Allows same interface for different FS"},
            {term: "Block Device", definition: "Device that stores information in fixed-size blocks", category: "I/O", example: "Hard disk, SSD"},
            {term: "Character Device", definition: "Device that provides stream of characters", category: "I/O", example: "Keyboard, printer"},
            {term: "Device Controller", definition: "Hardware component between device and computer", category: "I/O", example: "Disk controller, network controller"},
            {term: "Memory-Mapped I/O", definition: "I/O registers mapped into memory address space", category: "I/O", example: "Access like memory"},
            {term: "Port-Mapped I/O", definition: "I/O registers accessed via special port numbers", category: "I/O", example: "Special IN/OUT instructions"},
            {term: "Polling", definition: "CPU repeatedly checks device status", category: "I/O", example: "Busy waiting for I/O"},
            {term: "Interrupt-Driven I/O", definition: "Device interrupts CPU when I/O complete", category: "I/O", example: "More efficient than polling"},
            {term: "Device Driver", definition: "Device-specific code that controls hardware", category: "I/O", example: "Translates OS requests to device commands"},
            {term: "Disk Scheduling", definition: "Algorithm to order disk I/O requests", category: "I/O", example: "Minimize seek time"},
            {term: "SSTF (Shortest Seek Time First)", definition: "Schedule request with minimum seek time", category: "I/O", example: "Better than FCFS but may starve"},
            {term: "SCAN (Elevator Algorithm)", definition: "Disk arm moves from one end to other servicing requests", category: "I/O", example: "Uniform wait time"},
            {term: "C-SCAN", definition: "Like SCAN but returns to beginning without servicing", category: "I/O", example: "More uniform than SCAN"},
            {term: "C-LOOK", definition: "Version of C-SCAN that only goes to last request", category: "I/O", example: "Most efficient SCAN variant"},
            {term: "RAID (Redundant Array of Independent Disks)", definition: "Multiple disks for performance and/or reliability", category: "I/O", example: "RAID 0: striping, RAID 1: mirroring"}
        ];
        
        // Load flashcards from embedded data
        function loadFlashcards() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.style.display = 'none';
            
            if (flashcardData && flashcardData.length > 0) {
                document.getElementById('totalTerms').textContent = flashcardData.length;
                displayFlashcards(flashcardData);
            } else {
                errorDiv.textContent = 'No flashcard data available.';
                errorDiv.style.display = 'block';
            }
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (currentView === 'card' && document.getElementById('flashcardViewer').classList.contains('active')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    previousCard();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    nextCard();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    flipCard();
                }
            }
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function showStudyGuide() {
            hideAllViewers();
            document.getElementById('studyGuideViewer').classList.add('active');
            window.scrollTo({ top: document.getElementById('studyGuideViewer').offsetTop - 20, behavior: 'smooth' });
        }
        
        function showCheatSheet() {
            hideAllViewers();
            document.getElementById('cheatSheetViewer').classList.add('active');
            window.scrollTo({ top: document.getElementById('cheatSheetViewer').offsetTop - 20, behavior: 'smooth' });
        }
        
        function showFlashcards() {
            hideAllViewers();
            document.getElementById('flashcardViewer').classList.add('active');
            loadFlashcards();
            window.scrollTo({ top: document.getElementById('flashcardViewer').offsetTop - 20, behavior: 'smooth' });
        }
        
        function hideViewer(viewerId) {
            document.getElementById(viewerId).classList.remove('active');
        }
        
        function hideAllViewers() {
            document.querySelectorAll('.iframe-container, .csv-viewer').forEach(el => {
                el.classList.remove('active');
            });
        }
        
        // Flashcard state
        let currentCardIndex = 0;
        let filteredData = [];
        let currentView = 'card';
        
        // Display flashcards
        function displayFlashcards(data) {
            filteredData = data;
            currentCardIndex = 0;
            
            // Populate category filter
            const categories = [...new Set(data.map(item => item.category))].sort();
            const categorySelect = document.getElementById('categoryFilter');
            categorySelect.innerHTML = '<option value="">All Categories</option>';
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                categorySelect.appendChild(option);
            });
            
            // Update stats
            document.getElementById('showingTerms').textContent = filteredData.length;
            
            // Display current card or list
            if (currentView === 'card') {
                displayCard();
            } else {
                displayList();
            }
        }
        
        // Display current card
        function displayCard() {
            if (filteredData.length === 0) {
                document.getElementById('cardTerm').textContent = 'No cards to display';
                document.getElementById('cardDefinition').textContent = '';
                document.getElementById('cardExample').textContent = '';
                document.getElementById('cardCategory').textContent = '';
                document.getElementById('cardCategoryBack').textContent = '';
                return;
            }
            
            const card = filteredData[currentCardIndex];
            document.getElementById('cardCategory').textContent = card.category;
            document.getElementById('cardCategoryBack').textContent = card.category;
            document.getElementById('cardTerm').textContent = card.term;
            document.getElementById('cardDefinition').textContent = card.definition;
            document.getElementById('cardExample').innerHTML = card.example ? `<strong>Example:</strong> ${escapeHtml(card.example)}` : '';
            
            // Reset flip state
            const flashcardEl = document.getElementById('flashcard');
            flashcardEl.classList.remove('flipped');
            
            // Update counter
            document.getElementById('cardCounter').textContent = `${currentCardIndex + 1} / ${filteredData.length}`;
            document.getElementById('currentCard').textContent = currentCardIndex + 1;
            
            // Update nav buttons
            document.getElementById('prevBtn').disabled = currentCardIndex === 0;
            document.getElementById('nextBtn').disabled = currentCardIndex === filteredData.length - 1;
            
            // Force reflow to ensure proper rendering
            void flashcardEl.offsetHeight;
        }
        
        // Display list view
        function displayList() {
            const tbody = document.getElementById('flashcardBody');
            tbody.innerHTML = '';
            
            filteredData.forEach((card, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(card.term)}</td>
                    <td>${escapeHtml(card.definition)}</td>
                    <td>${escapeHtml(card.category)}</td>
                    <td>${escapeHtml(card.example || '')}</td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Switch between card and list view
        function switchView(view) {
            currentView = view;
            
            if (view === 'card') {
                const cardView = document.getElementById('cardView');
                cardView.style.display = 'flex';
                document.getElementById('listView').style.display = 'none';
                document.getElementById('cardViewBtn').classList.add('active');
                document.getElementById('listViewBtn').classList.remove('active');
                // Small delay to ensure display change is applied
                setTimeout(() => {
                    displayCard();
                }, 10);
            } else {
                document.getElementById('cardView').style.display = 'none';
                document.getElementById('listView').style.display = 'block';
                document.getElementById('listViewBtn').classList.add('active');
                document.getElementById('cardViewBtn').classList.remove('active');
                displayList();
            }
        }
        
        // Flip card
        function flipCard() {
            document.getElementById('flashcard').classList.toggle('flipped');
        }
        
        // Navigate cards
        function nextCard() {
            if (currentCardIndex < filteredData.length - 1) {
                currentCardIndex++;
                displayCard();
            }
        }
        
        function previousCard() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                displayCard();
            }
        }
        
        // Search functionality
        function handleSearch() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const category = document.getElementById('categoryFilter').value;
            
            let filtered = flashcardData;
            
            // Filter by category
            if (category) {
                filtered = filtered.filter(item => item.category === category);
            }
            
            // Filter by search term
            if (searchTerm) {
                filtered = filtered.filter(item => 
                    item.term.toLowerCase().includes(searchTerm) ||
                    item.definition.toLowerCase().includes(searchTerm) ||
                    item.category.toLowerCase().includes(searchTerm) ||
                    (item.example && item.example.toLowerCase().includes(searchTerm))
                );
            }
            
            displayFlashcards(filtered);
        }
        
        // Category filter
        function handleCategoryFilter() {
            handleSearch();
        }
        
        // Initialize flashcards on page load
        window.addEventListener('DOMContentLoaded', function() {
            if (flashcardData && flashcardData.length > 0) {
                // Will be initialized when viewer is opened
            }
        });
    </script>
    <style>
        .csv-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        
        .csv-table th,
        .csv-table td {
            border: 1px solid #222;
            padding: 10px;
            text-align: left;
        }
        
        .csv-table th {
            background: #111;
            color: #fff;
            font-weight: 500;
        }
        
        .csv-table td {
            color: #aaa;
        }
        
        .csv-table tr:hover {
            background: #111;
        }
    </style>
</body>
</html>
