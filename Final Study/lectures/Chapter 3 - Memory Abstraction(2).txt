Modern Operating Systems
Fifth Edition

Chapter 3
Memory Abstractions

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

No Memory Abstraction: Monoprogramming
Three simple ways of organizing memory with an operating system
and one user process. Other possibilities also exist.

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

No Memory Abstraction:
Multiprogramming
Illustration of the relocation problem.

A 16-KB program.

Another 16-KB program.

The two programs loaded
consecutively into memory.

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

No Memory Abstraction: Multiprogramming
Naive approach:
Move each program to a
dedicated region
Problems:
• Relocation
– Load-time?
• Protection
– Memory keys?
Figure 3.2 Relocation problem. Two 16 K B programs loaded consecutively into memory.
Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Address Spaces
Limit Register

• Base Register: starting
address in memory
Base Register

• Limit Register: upper
bound of address space

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Memory Abstraction
Limit Register

• Base register operates dynamic
relocation
• Limit register enforces protection

Base Register

What’s checked when MOV Reg1, Addr is executed?

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Base and Limit Registers
 A pair of base and limit

registers define the logical
address space

 CPU must check every memory

access generated in user mode

base

limit

 Each access must be between

base and limit for that user

Operating System Concepts – 10th Edition

9.7

Silberschatz, Galvin and Gagne ©2018

Hardware Address Protection

Operating System Concepts – 10th Edition

9.8

Silberschatz, Galvin and Gagne ©2018

Binding of Instructions and Data to Memory
Address binding of instructions and data to memory addresses can happen at three different stages.

Compile time

Load Time

Execution time

If memory location known ahead
of time, absolute code can be
generated.

Must generate relocatable code
if memory location is not known
at compile time

If the process’s memory location
can be moved during execution,
binding is delayed until runtime.

Must recompile code if starting
location changes.

Operating System Concepts – 10th Edition

Needs hardware support for
address maps (e.g., base and
limit registers)

9.9

Silberschatz, Galvin and Gagne ©2018

Multistep Processing of a User Program

Operating System Concepts – 10th Edition

9.10

Silberschatz, Galvin and Gagne ©2018

Memory-Management Unit (MMU)


Hardware device



Maps virtual to physical address at run time




Consider a scheme where the relocation register’s value is added to every address
generated by a user process when sent to memory




Many methods possible

Base register now called relocation register*

User programs deal with logical addresses; they never see real physical addresses


Execution-time binding occurs when references are made to location in memory



Logical address bound to physical addresses

*The MS-DOS on Intel 80x86 used 4 relocation registers!
Operating System Concepts – 10th Edition

9.11

Silberschatz, Galvin and Gagne ©2018

Dynamic relocation using a relocation register



Routine not loaded until called; better
memory utilization



Routines kept on disk in relocatable load
format



Useful when large amounts of code are
needed to handle infrequent cases

Operating System Concepts – 10th Edition

9.12

Silberschatz, Galvin and Gagne ©2018

Dynamic Relocation: Implementation

No special support from the OS is required!





Implemented through program design



OS can help by providing libraries to
implement dynamic loading

Operating System Concepts – 10th Edition

9.13

Silberschatz, Galvin and Gagne ©2018

Static vs. Dynamic Linking
Static Linking
Loader helps create

+
System Libraries

Binary Program Image

Program Code

Dynamic Linking
runs code

stub (code)
links at execution time

Binary Program Image

Operating System Concepts – 10th Edition

Program Code

9.14

System Libraries

Silberschatz, Galvin and Gagne ©2018

 Stub used to locate the

appropriate library routine inmemory
 Code stub replaces itself with

the address of the routine
and executes the routine

Dynamic Linking
(Shared Libraries)
Process

 OS checks if routine is in

process’s memory space
 If not in address space, adds

to address space

Operating System Concepts – 10th Edition

9.15

Silberschatz, Galvin and Gagne ©2018

 Particularly useful for

libraries (shared code)

Dynamic Linking
(Shared Libraries)
Benefits

 Updating system libraries is

more efficient/easier

 Version numbers/names

may be needed

Operating System Concepts – 10th Edition

9.16

Silberschatz, Galvin and Gagne ©2018

What If We Run Out of Memory?
• Process Swapping (simplest solution)
– Bring in entire process -> run it -> eventually put it back on
disk/SSD
– Idle processes don’t take up memory when not running

• Alternatively: virtual memory -> We will discuss this later!

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Swapping
 A process can be swapped

temporarily out of memory to a
backing store, and then brought
back into memory for continued
execution
 Total physical memory space of

processes can exceed physical
memory

Operating System Concepts – 10th Edition

Backing store: fast disk large enough to accommodate copies of all
memory images for all users

9.18

Silberschatz, Galvin and Gagne ©2018

 Backing store must provide

direct access to memory
images

Swapping (Cont.)

 Transfer time is a major

part of swap time; total
transfer time is directly
proportional to the amount
of memory swapped

Operating System Concepts – 10th Edition

9.19

Silberschatz, Galvin and Gagne ©2018

Swapping: More Concepts

Roll out, Roll in

Ready Queue

Swapping variant for priority-based scheduling.

The system maintains a queue of ready-to-run
processes which have memory images on disk.

Lower-priority process are swapped out so
higher-priority process can be loaded and
executed

Operating System Concepts – 10th Edition

9.20

Silberschatz, Galvin and Gagne ©2018

Swapping (Cont.)
 Does the swapped out process need to swap back in to the same

physical addresses?

 Depends on address binding method
 Also consider pending I/O to / from process memory space

 Modified versions of swapping are found on many systems (i.e.,

UNIX, Linux, and Windows)

 Swapping usually disabled
 Memory demand enables and disables swapping

Operating System Concepts – 10th Edition

9.21

Silberschatz, Galvin and Gagne ©2018

Improvement: Dynamic Partitions and Swapping
Memory allocation changes as processes come into memory
and leave it. The shaded regions are unused memory.

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Improvement: Dynamic Partitions and Swapping
Allocating space for a growing data
segment:

Allocating space for a growing stack and a
growing data segment:

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Memory Management: Bitmaps versus Linked Lists
(a) A part of memory with five processes and three holes. The tick marks show
the memory allocation units. The shaded regions (0 in the bitmap) are free.
(b) The corresponding bitmap.
(c) The same information as a list.

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Memory Management with Linked Lists
Four neighbor combinations for the terminating process, X.

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Memory Allocation Schemes
• First Fit: Take first fitting hole (MINI X 3)
– Simplest option
• Next Fit: Take next fitting hole
– Slower than first fit in practice
• Best Fit: Take best fitting hole
– Prone to fragmentation
• Worst Fit: Take worst fitting hole
– Poor performance in practice
• Quick Fit: Keep holes of different sizes
– Poor coalescing performance
Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Internal vs. External Fragmentation

External Fragmentation: enough overall memory for a request,
not enough contiguous memory
Internal Fragmentation: individual processes are ‘wasting’
memory; enough unused memory exists, but it’s hidden within
allocated blocks.

Operating System Concepts – 10th Edition

9.27

Silberschatz, Galvin and Gagne ©2018

 First fit analysis: 0.5 blocks are lost to

fragmentation for every block allocated
 1/3 may be unusable -> 50-percent

rule

Fragmentation (Cont.)

 Consider that backing store has same

fragmentation problems
 Reduce external fragmentation by

compaction

Operating System Concepts – 10th Edition

9.28

Silberschatz, Galvin and Gagne ©2018

Compaction
 Method: Shuffle memory contents to place all free memory together in one

large block
 Possible only if relocation is dynamic, and is done at execution time
 I/O problem: wrong addresses possible! Possible fixes?
 Latch job in memory (freeze in place) while it is involved in I/O
 Do I/O only into OS-managed buffers

Operating System Concepts – 10th Edition

9.29

Silberschatz, Galvin and Gagne ©2018

Modern Operating Systems
Fifth Edition

Chapter 3
Memory Abstractions - End

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

