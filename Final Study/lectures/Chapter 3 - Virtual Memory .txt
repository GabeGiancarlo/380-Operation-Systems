Modern Operating Systems
Fifth Edition

Chapter 3
Virtual Memory

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Virtual Memory
• There is a need to run programs that are too large to fit in memory
• Solution adopted in the 1960s, split programs into little pieces, called
overlays
– Kept on the disk, swapped in and out of memory
– Initially, only the overlay manager (O M) was loaded
– The O M would then load overlay 0 and run it
– When done, it would tell the O M to load overlay 1, etc.
• Nowadays, we have a better solution: virtual memory
– Often implemented using paging/segmenatation

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Virtual Memory
Problem: So far memory can only be given to processes in contiguous pieces
Solution:
• Create for the process the illusion of a
large (e.g., 48 bit) address space
• This is known as the virtual address space
• The (much more limited) RA M is known as
physical memory
• Translate virtual addresses (as used by
Figure 3.8 The position and function of the MM
the process) into physical addresses
U.
• Typically done in the MM U

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Segmentation
Memory-management scheme that supports user view of memory
 A program is a collection of segments
 A segment is a logical unit such as:
main program
procedure
function
method
object
local variables, global variables
common block
stack
symbol table
arrays


Operating System Concepts – 10th Edition

9.4

Silberschatz, Galvin and Gagne ©2018

User’s View of a Program

Operating System Concepts – 10th Edition

9.5

Silberschatz, Galvin and Gagne ©2018

Logical View of Segmentation
1
4

1
2

3

2

4

3

user space

Operating System Concepts – 10th Edition

physical memory space

9.6

Silberschatz, Galvin and Gagne ©2018

Segmentation Architecture


Logical address consists of a two tuple:
<segment-number, offset>,



Segment table – maps two-dimensional physical addresses; each
table entry has:


base – contains the starting physical address where the
segments reside in memory



limit – specifies the length of the segment



Segment-table base register (STBR) points to the segment
table’s location in memory



Segment-table length register (STLR) indicates number of
segments used by a program;
segment number s is legal if s < STLR

Operating System Concepts – 10th Edition

9.7

Silberschatz, Galvin and Gagne ©2018

Segmentation Hardware

Operating System Concepts – 10th Edition

9.8

Silberschatz, Galvin and Gagne ©2018

Paging




Physical address space of a process can be noncontiguous;
process is allocated physical memory whenever the latter is
available


Avoids external fragmentation



Avoids problem of varying sized memory chunks

Divide physical memory into fixed-sized blocks called frames


Size is power of 2, between 512 bytes and 16 Mbytes



Divide logical memory into blocks of same size called pages



Keep track of all free frames



To run a program of size N pages, need to find N free frames and
load program



Set up a page table to translate logical to physical addresses



Backing store likewise split into pages



Still have Internal fragmentation

Operating System Concepts – 10th Edition

9.9

Silberschatz, Galvin and Gagne ©2018

Address Translation Scheme


Address generated by CPU is divided into:


Page number (p) – used as an index into a page table which
contains base address of each page in physical memory



Page offset (d) – combined with base address to define the
physical memory address that is sent to the memory unit



Operating System Concepts – 10th Edition

page number

page offset

p

d

m -n

n

For given logical address space 2m and page size 2n

9.10

Silberschatz, Galvin and Gagne ©2018

Paging Hardware

Operating System Concepts – 10th Edition

9.11

Silberschatz, Galvin and Gagne ©2018

Paging Model of Logical and Physical Memory

Operating System Concepts – 10th Edition

9.12

Silberschatz, Galvin and Gagne ©2018

Paging (Cont.)


Calculating internal fragmentation


Page size = 2,048 bytes



Process size = 72,766 bytes



35 pages + 1,086 bytes



Internal fragmentation of 2,048 - 1,086 = 962 bytes



Worst case fragmentation = 1 frame – 1 byte



On average fragmentation = 1 / 2 frame size



So small frame sizes desirable?



But each page table entry takes memory to track



Page sizes growing over time
 Solaris supports two page sizes – 8 KB and 4 MB



Process view and physical memory now very different



By implementation process can only access its own memory

Operating System Concepts – 10th Edition

9.13

Silberschatz, Galvin and Gagne ©2018

Implementation of Page Table


Page table is kept in main memory



Page-table base register (PTBR) points to the page table



Page-table length register (PTLR) indicates size of the page
table



In this scheme every data/instruction access requires two
memory accesses




One for the page table and one for the data / instruction

The two memory access problem can be solved by the use of
a special fast-lookup hardware cache called associative
memory or translation look-aside buffers (TLBs)

Operating System Concepts – 10th Edition

9.14

Silberschatz, Galvin and Gagne ©2018

Implementation of Page Table (Cont.)


Some TLBs store address-space identifiers (ASIDs) in each
TLB entry – uniquely identifies each process to provide
address-space protection for that process


Otherwise need to flush at every context switch



TLBs typically small (64 to 1,024 entries)



On a TLB miss, value is loaded into the TLB for faster access
next time

Operating System Concepts – 10th Edition



Replacement policies must be considered



Some entries can be wired down for permanent fast
access

9.15

Silberschatz, Galvin and Gagne ©2018

Associative Memory


Associative memory – parallel search
P age #



Operating System Concepts – 10th Edition

F rame #

Address translation (p, d)


If p is in associative register, get frame # out



Otherwise get frame # from page table in memory

9.16

Silberschatz, Galvin and Gagne ©2018

Paging Hardware With TLB

Operating System Concepts – 10th Edition

9.17

Silberschatz, Galvin and Gagne ©2018

Effective Access Time









Operating System Concepts – 10th Edition

Associative Lookup =  time unit
 Can be < 10% of memory access time
Hit ratio = 
 Hit ratio – percentage of times that a page number is found in the
associative registers; ratio related to number of associative
registers
Consider  = 80%,  = 20ns for TLB search, 100ns for memory access
Effective Access Time (EAT)
EAT = (1 + )  + (2 + )(1 – )
=2+–
Consider  = 80%,  = 20ns for TLB search, 100ns for memory access
 EAT = 0.80 x 100 + 0.20 x 200 = 120ns
Consider more realistic hit ratio ->  = 99%,  = 20ns for TLB search,
100ns for memory access
 EAT = 0.99 x 100 + 0.01 x 200 = 101ns

9.18

Silberschatz, Galvin and Gagne ©2018

Memory Protection


Memory protection implemented by associating protection bit
with each frame to indicate if read-only or read-write access is
allowed






Can also add more bits to indicate page execute-only, and
so on

Valid-invalid bit attached to each entry in the page table:


“valid” indicates that the associated page is in the process’
logical address space, and is thus a legal page



“invalid” indicates that the page is not in the process’ logical
address space



Or use page-table length register (PTLR)

Any violations result in a trap to the kernel

Operating System Concepts – 10th Edition

9.19

Silberschatz, Galvin and Gagne ©2018

Valid (v) or Invalid (i) Bit In A Page Table

Operating System Concepts – 10th Edition

9.20

Silberschatz, Galvin and Gagne ©2018

Structure of the Page Table


Memory structures for paging can get huge using straightforward methods


Consider a 32-bit logical address space as on modern
computers



Page size of 4 KB (212)



Page table would have 1 million entries (232 / 212)



If each entry is 4 bytes -> 4 MB of physical address space /
memory for page table alone
 That amount of memory used to cost a lot
 Don’t want to allocate that contiguously in main memory



Hierarchical Paging



Hashed Page Tables



Inverted Page Tables

Operating System Concepts – 10th Edition

9.21

Silberschatz, Galvin and Gagne ©2018

Hierarchical Page Tables


Break up the logical address space into multiple page
tables



A simple technique is a two-level page table



We then page the page table

Operating System Concepts – 10th Edition

9.22

Silberschatz, Galvin and Gagne ©2018

Two-level Page Tables (x86)
Page tables are “walked” by hardware
M M U = Memory Management Unit

CR 3 register
(special register to point to
top of page table
hierarchy)
Figure 3.13 (a) A 32-bit address with two page
table fields. (b) Two-level page tables.
Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Two-Level Paging Example


A logical address (on 32-bit machine with 1K page size) is divided into:
 a page number consisting of 22 bits
 a page offset consisting of 10 bits



Since the page table is paged, the page number is further divided into:
 a 12-bit page number
 a 10-bit page offset



Thus, a logical address is as follows:

where p1 is an index into the outer page table, and p2 is the
displacement within the page of the inner page table
 Known as forward-mapped page table


Operating System Concepts – 10th Edition

9.24

Silberschatz, Galvin and Gagne ©2018

Address-Translation Scheme

Operating System Concepts – 10th Edition

9.25

Silberschatz, Galvin and Gagne ©2018

64-bit Logical Address Space


Even two-level paging scheme not sufficient



If page size is 4 KB (212)


Then page table has 252 entries



If two level scheme, inner page tables could be 210 4-byte entries



Address would look like



Outer page table has 242 entries or 244 bytes



One solution is to add a 2nd outer page table



But in the following example the 2nd outer page table is still 234 bytes in
size
 And possibly 4 memory access to get to one physical memory

location

Operating System Concepts – 10th Edition

9.26

Silberschatz, Galvin and Gagne ©2018

Three-level Paging Scheme

Operating System Concepts – 10th Edition

9.27

Silberschatz, Galvin and Gagne ©2018

Hashed Page Table

Operating System Concepts – 10th Edition

9.28

Silberschatz, Galvin and Gagne ©2018

Inverted Page Table


Rather than each process having a page table and keeping track
of all possible logical pages, track all physical pages



One entry for each real page of memory



Entry consists of the virtual address of the page stored in that
real memory location, with information about the process that
owns that page



Decreases memory needed to store each page table, but
increases time needed to search the table when a page
reference occurs



Use hash table to limit the search to one — or at most a few —
page-table entries




But how to implement shared memory?


Operating System Concepts – 10th Edition

TLB can accelerate access
One mapping of a virtual address to the shared physical
address

9.29

Silberschatz, Galvin and Gagne ©2018

Inverted Page Tables (I A-64)

Figure 3.14 Comparison of a traditional page table with an inverted page table.
Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Virtual Memory That is Larger Than Physical Memory

Operating System Concepts – 10th Edition

10.31

Silberschatz, Galvin and Gagne ©2018

Demand Paging








Could bring entire process into memory
at load time
Or bring a page into memory only when
it is needed
 Less I/O needed, no unnecessary
I/O
 Less memory needed
 Faster response
 More users
Similar to paging system with swapping
(diagram on right)
Page is needed  reference to it
 invalid reference  abort
 not-in-memory  bring to memory
Lazy swapper – never swaps a page
into memory unless page will be needed
 Swapper that deals with pages is a
pager

Operating System Concepts – 10th Edition

10.32

Silberschatz, Galvin and Gagne ©2018

Basic Concepts


With swapping, pager guesses which pages will be used before
swapping out again



Instead, pager brings in only those pages into memory



How to determine that set of pages?




If pages needed are already memory resident




Need new MMU functionality to implement demand paging
No difference from non demand-paging

If page needed and not memory resident


Need to detect and load the page into memory from storage
 Without changing program behavior
 Without programmer needing to change code

Operating System Concepts – 10th Edition

10.33

Silberschatz, Galvin and Gagne ©2018

Valid-Invalid Bit
With each page table entry a valid–invalid bit is associated
(v  in-memory – memory resident, i  not-in-memory)
 Initially valid–invalid bit is set to i on all entries
 Example of a page table snapshot:




Operating System Concepts – 10th Edition

During MMU address translation, if valid–invalid bit in page table
entry is i  page fault
10.34

Silberschatz, Galvin and Gagne ©2018

Page Table When Some Pages Are Not in Main Memory

Operating System Concepts – 10th Edition

10.35

Silberschatz, Galvin and Gagne ©2018

Page Fault


1.

2.
3.
4.
5.

Operating System Concepts – 10th Edition

If there is a reference to a page, first reference to that page will
trap to operating system:
page fault
Operating system looks at another table to decide:
 Invalid reference  abort
 Just not in memory
Find free frame
Swap page into frame via scheduled disk operation
Reset tables to indicate page now in memory
Set validation bit = v
Restart the instruction that caused the page fault

10.36

Silberschatz, Galvin and Gagne ©2018

Steps in Handling a Page Fault

Operating System Concepts – 10th Edition

10.37

Silberschatz, Galvin and Gagne ©2018

Aspects of Demand Paging






Extreme case – start process with no pages in memory


OS sets instruction pointer to first instruction of process, nonmemory-resident -> page fault



And for every other process pages on first access



Pure demand paging

Actually, a given instruction could access multiple pages -> multiple
page faults


Consider fetch and decode of instruction which adds 2 numbers
from memory and stores result back to memory



Pain decreased because of locality of reference

Hardware support needed for demand paging

Operating System Concepts – 10th Edition



Page table with valid / invalid bit



Secondary memory (swap device with swap space)



Instruction restart

10.38

Silberschatz, Galvin and Gagne ©2018

Performance of Demand Paging


Stages in Demand Paging (worse case)

1.

Trap to the operating system

2.

Save the user registers and process state

3.

Determine that the interrupt was a page fault

4.

Check that the page reference was legal and determine the location of the page on the disk

5.

Issue a read from the disk to a free frame:
1.

Wait in a queue for this device until the read request is serviced

2.

Wait for the device seek and/or latency time

3.

Begin the transfer of the page to a free frame

6.

While waiting, allocate the CPU to some other user

7.

Receive an interrupt from the disk I/O subsystem (I/O completed)

8.

Save the registers and process state for the other user

9.

Determine that the interrupt was from the disk

10. Correct the page table and other tables to show page is now in memory
11. Wait for the CPU to be allocated to this process again
12. Restore the user registers, process state, and new page table, and then resume the

interrupted instruction

Operating System Concepts – 10th Edition

10.39

Silberschatz, Galvin and Gagne ©2018

Demand Paging Optimizations


Swap space I/O faster than file system I/O even if on the same device






Swap allocated in larger chunks, less management needed than file
system

Copy entire process image to swap space at process load time


Then page in and out of swap space



Used in older BSD Unix

Demand page in from program binary on disk, but discard rather than paging
out when freeing frame


Used in Solaris and current BSD



Still need to write to swap space
 Pages not associated with a file (like stack and heap) – anonymous

memory

 Pages modified in memory but not yet written back to the file system



Mobile systems

Operating System Concepts – 10th Edition



Typically don’t support swapping



Instead, demand page from file system and reclaim read-only pages (such
as code)

10.40

Silberschatz, Galvin and Gagne ©2018

Copy-on-Write


Copy-on-Write (COW) allows both parent and child processes to initially
share the same pages in memory


If either process modifies a shared page, only then is the page copied



COW allows more efficient process creation as only modified pages are
copied



In general, free pages are allocated from a pool of zero-fill-on-demand
pages


Pool should always have free frames for fast demand page execution
 Don’t want to have to free a frame as well as other processing on

page fault





Why zero-out a page before allocating it?

vfork() variation on fork() system call has parent suspend and child
using copy-on-write address space of parent

Operating System Concepts – 10th Edition



Designed to have child call exec()



Very efficient

10.41

Silberschatz, Galvin and Gagne ©2018

Before Process 1 Modifies Page C

Operating System Concepts – 10th Edition

10.42

Silberschatz, Galvin and Gagne ©2018

After Process 1 Modifies Page C

Operating System Concepts – 10th Edition

10.43

Silberschatz, Galvin and Gagne ©2018

What Happens if There is no Free Frame?


Used up by process pages



Also in demand from the kernel, I/O buffers, etc



How much to allocate to each?



Page replacement – find some page in memory, but not really in
use, page it out





Algorithm – terminate? swap out? replace the page?



Performance – want an algorithm which will result in minimum
number of page faults

Same page may be brought into memory several times

Operating System Concepts – 10th Edition

10.44

Silberschatz, Galvin and Gagne ©2018

Page Replacement
• Computer might use more virtual memory than it has physical
memory
• Paging creates the illusion of unlimited memory available to user
processes
• When a logical page is not in memory (swapped out to a
file/partition), the O S has to page it in on a page fault
• Swapping out: direct or indirect reclaim
• Another logical page has to be swapped out  which?

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

Need For Page Replacement

Operating System Concepts – 10th Edition

10.46

Silberschatz, Galvin and Gagne ©2018

Basic Page Replacement
1.

Find the location of the desired page on disk

2.

Find a free frame:
- If there is a free frame, use it
- If there is no free frame, use a page replacement algorithm to
select a victim frame
- Write victim frame to disk if dirty

3.

Bring the desired page into the (newly) free frame; update the page
and frame tables

4.

Continue the process by restarting the instruction that caused the trap

Note now potentially 2 page transfers for page fault – increasing EAT

Operating System Concepts – 10th Edition

10.47

Silberschatz, Galvin and Gagne ©2018

Page Replacement

Operating System Concepts – 10th Edition

10.48

Silberschatz, Galvin and Gagne ©2018

Page and Frame Replacement Algorithms




Frame-allocation algorithm determines


How many frames to give each process



Which frames to replace

Page-replacement algorithm






Want lowest page-fault rate on both first access and re-access

Evaluate algorithm by running it on a particular string of memory
references (reference string) and computing the number of page
faults on that string


String is just page numbers, not full addresses



Repeated access to the same page does not cause a page fault



Results depend on number of frames available

In all our examples, the reference string of referenced page
numbers is
7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1

Operating System Concepts – 10th Edition

10.49

Silberschatz, Galvin and Gagne ©2018

Graph of Page Faults Versus The Number of Frames

Operating System Concepts – 10th Edition

10.50

Silberschatz, Galvin and Gagne ©2018

First-In-First-Out (FIFO) Algorithm


Reference string: 7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1



3 frames (3 pages can be in memory at a time per process)



15 page faults

Can vary by reference string: consider 1,2,3,4,1,2,5,1,2,3,4,5


Adding more frames can cause more page faults!
 Belady’s Anomaly



How to track ages of pages?


Operating System Concepts – 10th Edition

Just use a FIFO queue

10.51

Silberschatz, Galvin and Gagne ©2018

FIFO Illustrating Belady’s Anomaly

Operating System Concepts – 10th Edition

10.52

Silberschatz, Galvin and Gagne ©2018

Optimal Algorithm


Replace page that will not be used for longest period of time




How do you know this?




Operating System Concepts – 10th Edition

9 is optimal for the example
Can’t read the future

Used for measuring how well your algorithm performs

10.53

Silberschatz, Galvin and Gagne ©2018

Least Recently Used (LRU) Algorithm


Use past knowledge rather than future



Replace page that has not been used in the most amount of time



Associate time of last use with each page



12 faults – better than FIFO but worse than OPT



Generally good algorithm and frequently used



But how to implement?

Operating System Concepts – 10th Edition

10.54

Silberschatz, Galvin and Gagne ©2018

LRU Algorithm (Cont.)


Counter implementation


Every page entry has a counter; every time page is referenced
through this entry, copy the clock into the counter



When a page needs to be changed, look at the counters to find
smallest value
 Search through table needed



Stack implementation


Keep a stack of page numbers in a double link form:



Page referenced:
 move it to the top
 requires 6 pointers to be changed



Operating System Concepts – 10th Edition



But each update more expensive



No search for replacement

LRU and OPT are cases of stack algorithms that don’t have
Belady’s Anomaly

10.55

Silberschatz, Galvin and Gagne ©2018

Use Of A Stack to Record Most Recent Page References

Operating System Concepts – 10th Edition

10.56

Silberschatz, Galvin and Gagne ©2018

LRU Approximation Algorithms


LRU needs special hardware and still slow



Reference bit


With each page associate a bit, initially = 0



When page is referenced bit set to 1



Replace any with reference bit = 0 (if one exists)
 We do not know the order, however



Second-chance algorithm


Generally FIFO, plus hardware-provided reference bit



Clock replacement



If page to be replaced has
 Reference bit = 0 -> replace it
 reference bit = 1 then:

Operating System Concepts – 10th Edition

–

set reference bit 0, leave page in memory

–

replace next page, subject to same rules

10.57

Silberschatz, Galvin and Gagne ©2018

Second-Chance (clock) Page-Replacement Algorithm

Operating System Concepts – 10th Edition

10.58

Silberschatz, Galvin and Gagne ©2018

Enhanced Second-Chance Algorithm


Improve algorithm by using reference bit and modify bit (if
available) in concert



Take ordered pair (reference, modify)

1. (0, 0) neither recently used not modified – best page to replace
2. (0, 1) not recently used but modified – not quite as good, must

write out before replacement

3. (1, 0) recently used but clean – probably will be used again soon
4. (1, 1) recently used and modified – probably will be used again

soon and need to write out before replacement



When page replacement called for, use the clock scheme but
use the four classes replace page in lowest non-empty class


Operating System Concepts – 10th Edition

Might need to search circular queue several times

10.59

Silberschatz, Galvin and Gagne ©2018

Counting Algorithms


Keep a counter of the number of references that have been made
to each page


Not common



Lease Frequently Used (LFU) Algorithm: replaces page with
smallest count



Most Frequently Used (MFU) Algorithm: based on the argument
that the page with the smallest count was probably just brought in
and has yet to be used

Operating System Concepts – 10th Edition

10.60

Silberschatz, Galvin and Gagne ©2018

Page-Buffering Algorithms




Keep a pool of free frames, always


Then frame available when needed, not found at fault time



Read page into free frame and select victim to evict and add
to free pool



When convenient, evict victim

Possibly, keep list of modified pages




When backing store otherwise idle, write pages there and set
to non-dirty

Possibly, keep free frame contents intact and note what is in them

Operating System Concepts – 10th Edition



If referenced again before reused, no need to load contents
again from disk



Generally useful to reduce penalty if wrong victim frame
selected

10.61

Silberschatz, Galvin and Gagne ©2018

Applications and Page Replacement


All of these algorithms have OS guessing about future page
access



Some applications have better knowledge – i.e. databases



Memory intensive applications can cause double buffering





OS keeps copy of page in memory as I/O buffer



Application keeps page in memory for its own work

Operating system can given direct access to the disk, getting out
of the way of the applications




Operating System Concepts – 10th Edition

Raw disk mode

Bypasses buffering, locking, etc

10.62

Silberschatz, Galvin and Gagne ©2018

Allocation of Frames


Each process needs minimum number of frames



Example: IBM 370 – 6 pages to handle SS MOVE instruction:


instruction is 6 bytes, might span 2 pages



2 pages to handle from



2 pages to handle to



Maximum of course is total frames in the system



Two major allocation schemes



Operating System Concepts – 10th Edition



fixed allocation



priority allocation

Many variations

10.63

Silberschatz, Galvin and Gagne ©2018

Fixed Allocation


Equal allocation – For example, if there are 100 frames (after
allocating frames for the OS) and 5 processes, give each process
20 frames




Keep some as free frame buffer pool

Proportional allocation – Allocate according to the size of process


Dynamic as degree of multiprogramming, process sizes
change

si size of process pi
S   si
m total number of frames
s
ai allocation for pi  i m
S

Operating System Concepts – 10th Edition

10.64

Silberschatz, Galvin and Gagne ©2018

Priority Allocation


Use a proportional allocation scheme using priorities rather
than size



If process Pi generates a page fault,

Operating System Concepts – 10th Edition



select for replacement one of its frames



select for replacement a frame from a process with lower
priority number

10.65

Silberschatz, Galvin and Gagne ©2018

Global vs. Local Allocation




Global replacement – process selects a replacement frame
from the set of all frames; one process can take a frame from
another


But then process execution time can vary greatly



But greater throughput so more common

Local replacement – each process selects from only its own
set of allocated frames

Operating System Concepts – 10th Edition



More consistent per-process performance



But possibly underutilized memory

10.66

Silberschatz, Galvin and Gagne ©2018

Thrashing


If a process does not have “enough” pages, the page-fault rate is
very high


Page fault to get page



Replace existing frame



But quickly need replaced frame back



This leads to:
 Low CPU utilization
 Operating system thinking that it needs to increase the

degree of multiprogramming

 Another process added to the system



Operating System Concepts – 10th Edition

Thrashing  a process is busy swapping pages in and out

10.67

Silberschatz, Galvin and Gagne ©2018

Thrashing (Cont.)

Operating System Concepts – 10th Edition

10.68

Silberschatz, Galvin and Gagne ©2018

Demand Paging and Thrashing




Why does demand paging work?
Locality model


Process migrates from one locality to another



Localities may overlap

Why does thrashing occur?
 size of locality > total memory size


Operating System Concepts – 10th Edition

Limit effects by using local or priority page replacement

10.69

Silberschatz, Galvin and Gagne ©2018

Locality In A Memory-Reference Pattern

Operating System Concepts – 10th Edition

10.70

Silberschatz, Galvin and Gagne ©2018

Working-Set Model


  working-set window  a fixed number of page references
Example: 10,000 instructions



WSSi (working set of Process Pi) =
total number of pages referenced in the most recent  (varies in time)





if  too small will not encompass entire locality



if  too large will encompass several localities



if  =   will encompass entire program

D =  WSSi  total demand frames


Approximation of locality



if D > m  Thrashing



Policy if D > m, then suspend or swap out one of the processes

Operating System Concepts – 10th Edition

10.71

Silberschatz, Galvin and Gagne ©2018

Keeping Track of the Working Set


Approximate with interval timer + a reference bit



Example:  = 10,000


Timer interrupts after every 5000 time units



Keep in memory 2 bits for each page



Whenever a timer interrupts copy and sets the values of all
reference bits to 0



If one of the bits in memory = 1  page in working set



Why is this not completely accurate?



Improvement = 10 bits and interrupt every 1000 time units

Operating System Concepts – 10th Edition

10.72

Silberschatz, Galvin and Gagne ©2018

Page-Fault Frequency


More direct approach than WSS



Establish “acceptable” page-fault frequency (PFF) rate
and use local replacement policy

Operating System Concepts – 10th Edition



If actual rate too low, process loses frame



If actual rate too high, process gains frame

10.73

Silberschatz, Galvin and Gagne ©2018

Working Sets and Page Fault Rates


Direct relationship between working set of a process and its page-fault rate



Working set changes over time



Peaks and valleys over time

Operating System Concepts – 10th Edition

10.74

Silberschatz, Galvin and Gagne ©2018

Modern Operating Systems
Fifth Edition

Chapter 3 - End
Virtual Memory

Copyright © 2023, 2014, 2008 Pearson Education, Inc. All Rights Reserved

